#java #collections #ArrayList 

`Коллекции (Collections)` в Java — это мощный и гибкий фреймворк, предназначенный для работы с группами объектов. Они предоставляют абстракции и интерфейсы для хранения, обработки и управления данными. В отличие от массивов, коллекции могут динамически менять свой размер и предлагают множество готовых методов для работы с данными.

### Примеры использования

```java
ArrayList<Integer> numbers = new ArrayList<>(); // 5 numbers list, 0 in unitil 5  
ArrayList<String> collectionString = new ArrayList<>(); // 1 - name  
ArrayList<String> myNames = getMyArrayList(); // 5 names list  
  
for (int i = 0; i < 5; i++) {  
    numbers.add(i);  
    collectionString.add(numbers.get(i) + " - " + myNames.get(i));  
}  
  
for (String result : collectionString) {  
    System.out.println(result);  
}
```

**Основные реализации коллекций:**

- [[ArrayList]]
    - Реализация `List` на основе массива.
    - Быстрый доступ к элементам по индексу.
    - Медленное добавление/удаление элементов в середине списка.
    - Хорошо подходит для частого доступа к элементам, нечастых вставок/удалений.
- **`LinkedList`:**
    - Реализация `List` на основе двусвязного списка.
    - Быстрое добавление/удаление элементов в середине списка.
    - Медленный доступ к элементам по индексу.
    - Хорошо подходит для частого добавления/удаления элементов в разных местах списка.
- **[[HashSet]]:**
    - Реализация `Set` на основе хеш-таблицы.
    - Быстрый поиск, добавление и удаление элементов.
    - Не сохраняет порядок элементов.
    - Хорошо подходит для хранения уникальных значений без требования к порядку.
- **`LinkedHashSet`:**
    - Реализация `Set` на основе хеш-таблицы и связанного списка.
    - Сохраняет порядок добавления элементов.
    - Используется, если важен порядок, в котором были добавлены элементы.
- **`TreeSet`:**
    - Реализация `Set` на основе сбалансированного бинарного дерева.
    - Автоматически сортирует элементы в натуральном порядке или по заданному компаратору.
    - Хорошо подходит для хранения отсортированных уникальных значений.
- **`HashMap`:**
    - Реализация `Map` на основе хеш-таблицы.
    - Быстрый поиск, добавление и удаление пар “ключ-значение”.
    - Не сохраняет порядок элементов.
    - Хорошо подходит для быстрого доступа к значениям по ключу, когда порядок не важен.
- **`LinkedHashMap`:**
    - Реализация `Map` на основе хеш-таблицы и связанного списка.
    - Сохраняет порядок добавления элементов (или порядок доступа при настройке).
    - Подходит, если важен порядок, в котором были добавлены или использованы пары “ключ-значение”.
- **`TreeMap`:**
    - Реализация `Map` на основе сбалансированного бинарного дерева.
    - Автоматически сортирует ключи в натуральном порядке или по заданному компаратору.
    - Хорошо подходит, если ключи должны быть отсортированы.
- **`PriorityQueue`:**
    - Реализация `Queue`, основанная на куче.
    - Элементы удаляются в соответствии с приоритетом, заданным компаратором.