#Retrofit #RxJava #json #stream #Gradle #Room #Single #DAO 
### Проблемы ручной реализации

Проблемы заключаются в том, что ее тяжело реализовать, особенно, если `JSON-ответ` является огромным, да ещё с массивами. По этой причине практически никто так не реализовывает логику.

Чтобы мы не работали напрямую с преобразованием, получение `JSON-ответа` и пр. рутинные действия с `Stream API`, была придумана библиотека `Retrofit`. Главная задача, он все эти действия перекладывает на себя и нам не нужно об этом беспокоиться, достаточно знать нужные методы, благодаря которому будет реализована такая же логика, но в упрощенном виде. 

Он требуют добавление в `Gradle Modules` как зависимость (Он самый, `JSON-преобразование` и возможность работать с `RxJava`).
### Реализация `Retrofit`:

Она очень схожа с реализаций `Room`: создать интерфейс, где будут методы и потенциальный суперкласс, в котором мы создаем потенциального наследника, который реализует логику методов из интерфейса и нужную логику из суперкласса.

Для этого создаем интерфейс, самое частое название интерфейса «`ApiService`». После создания нам нужен теперь класс, который реализует методы из него. Очень схоже со ситуаций интерфейса `Dao`, его методы были реализованы в классе `Database`. 

Классы, которые реализует методы из той интерфейса и реализует класс-наследника, называют «`ApiFactory`». Реализация этого интерфейса должна быть одна, нужно использовать паттерн `Singleton`. 

Создание реализации будет заниматься `Retrofit`. Создавать будем через `Builder`.

Следующее методы, которые нам нужны для реализации:

- `baseURL()` — метод, который предоставляет наш `URL` для дальнейшего работы. А то как `Retrofit` будет получать картинки со собак?
- `addConverterFactory(GsonConverterFactory.create())` — данный метод преобразует ответ в конкретный объект для `Java`. Мы получаем `JSON-ответ` и мы его переделываем в `Java-объект`.
- `addCallAdapterFactory(RxJava3CallAdapterFactory.create())` — данный метод добавляет поддержку `RxJava` для класса.
- `build()` — создает класс под капотом.

И последним шагом является теперь создание его в классе наследника, а именно через экземпляра класса вызвать метод `create()` и указать наш интерфейс.

Однако, наш интерфейс пока не готов, нужно указать аннотацию, которая говорит наследнику, что будет делать этот метод. В нашем случае нужна аннотация `@GET`. Но это ещё не всё, мы можем ещё указать end-point

`End-point` — это конец ссылки, которая является часто изменяемый, в отличие от `BASE_URL`.

Пример:
[https://dog.ceo/api/breeds/image/random](https://dog.ceo/api/breeds/image/random) — красная — это `base_url`, а голубое — это `end-point`
[https://dog.ceo/api/breeds/name/random](https://dog.ceo/api/breeds/name/random) — тут видим отличие, `base_url` не изменился, а вот `end-point` изменился.**

По этой причине нужно в `@GET` указывать `end-point`, а `BASE_URL` указывать ту ссылку, которая является основным и неизменяемым, важно, чтобы в конце была косая черта. Однако, в нашем случае мы используем всего одну ссылку. Если мы используем много ссылок, то обязательно нужно использовать `End-point`.
### Примеры использования:

*ApiFactory.java*
```java
public class ApiFactory {  
    private static final String BASE_URL = "https://dog.ceo/api/breeds/image/";  
  
    private static ApiService apiService;  
  
    public static ApiService getApiService() {  
        if (apiService == null) {  
            Retrofit retrofit = new Retrofit.Builder()  
                    .baseUrl(BASE_URL)  
                    .addConverterFactory(GsonConverterFactory.create())  
                    .addCallAdapterFactory(RxJava3CallAdapterFactory.create())  
                    .build();  
            apiService = retrofit.create(ApiService.class);  
        }  
        return apiService;  
    }  
}
```

*ApiService.java*
```java
public interface ApiService {  
    @GET("random")  
    Single<DogImage> loadDogImage();  
}
```
