#kotlin #scoreFunction #let #also #with #apply #null #it
### Основные понятия

`let`, `also`, `with`, и `apply` — это так называемые “scope functions” (функции области видимости) в Kotlin. Они позволяют выполнять операции над объектом в определенной области видимости, делая код более читаемым и лаконичным. Все эти функции принимают лямбда-выражение, но отличаются способом доступа к объекту внутри лямбды и тем, что возвращают.
### Применение:

1. **`let`**
- **Как работает:**  
    - Вызывает лямбда-выражение с объектом в качестве аргумента (`it`).
    - Возвращает результат выполнения лямбда-выражения.
- **Когда использовать:**
    - Когда нужно выполнить какие-то операции над объектом и вернуть _результат этих операций_, а не сам объект.
    - Когда нужно выполнить код, только если объект не `null` (вместо `if (obj != null)`).
    - Когда нужно ограничить область видимости объекта, чтобы избежать конфликтов имен.
>[!success ] используется для проверки на `null`

   >[!success ] действия над объектом в конце цепочки

[[Пример использования оператора `let`]]

2. **`also`**
- **Как работает:**
    - Вызывает лямбда-выражение с объектом в качестве аргумента (`it`).
    - Возвращает _сам объект_.
- **Когда использовать:**
    - Когда нужно выполнить какие-то “побочные” действия с объектом (например, логирование, отправку уведомлений, изменение состояния), _не изменяя_ его и не влияя на дальнейшую цепочку вызовов.
    - Когда нужно выполнить действия, которые не зависят от результата этих действий.

>[!success ] Дополнительные действия, не влияющие на цепочку операторов

[[Пример использования оператора `also`]]

3. **`with`**
- **Как работает:**
    - Принимает объект и лямбда-выражение.
    - Выполняет лямбда-выражение, предоставляя доступ к свойствам и методам объекта _без явного указания имени объекта_. Внутри лямбды ты можешь обращаться к членам объекта напрямую.
    - Возвращает результат выполнения лямбда-выражения.
- **Когда использовать:**
    - Когда нужно выполнить несколько операций над одним и тем же объектом, и ты хочешь избежать повторения имени объекта.
    - Когда нужно сгруппировать операции над объектом в одном месте.

>[!success ] Много вызовов метода у одного объекта

[[Пример использования оператора `with`]]

4. **`apply`**
- **Как работает:**
    - Вызывает лямбда-выражение с объектом в качестве _receiver_ (внутри лямбды ты можешь обращаться к членам объекта напрямую, как в `with`).
    - Возвращает _сам объект_.
- **Когда использовать:**
    - Когда нужно инициализировать объект или сконфигурировать его свойства в одном блоке кода.
    - Когда нужно выполнить несколько операций над объектом и вернуть сконфигурированный объект.
    - Часто используется при создании объектов с большим количеством свойств.

>[!success ] Настройка объекта, после его создания

[[Пример использования оператора `apply`]]

5. **`run` как Extension Function (функция-расширение):**
- **Как работает:**
    - Вызывается на объекте.
    - Предоставляет объект в качестве `receiver` (внутри лямбда-выражения ты можешь обращаться к членам объекта напрямую через `this`).
    - Возвращает результат выполнения лямбда-выражения.
- **Когда использовать:**
    - Когда нужно выполнить несколько операций над объектом и вернуть _результат последней операции_ (или любое другое значение, вычисленное в лямбде). Это похоже на `with`, но вызывается как extension function, что может быть более читабельным в некоторых случаях.
    - Когда нужно объединить операции над объектом в одном месте, особенно если эти операции включают вызовы методов самого объекта.

[[Пример использования оператора `run`]]