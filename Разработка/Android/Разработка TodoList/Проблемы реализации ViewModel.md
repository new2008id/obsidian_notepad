#ViewModel #MutableLiveData #LiveData #MVVM #getter #setter #Activity #ViewModelProvider
### Основные понятия

Как говорилось ранее, мы создали экземпляр `ViewModel`, который является неправильным по следующим причинам:
##### MutableLiveData 

>[! ] Особенность данного класса заключается в том, что он является наследником `LiveData` и мы можем отправить данные в `LiveData`. Благодаря ему мы можем передать из `ViewModel` в `View` данные, не нарушая принцип `MVVM`. 

Чтобы добавить данные в `MutableLiveData`, используется метод `setValue()`. Если есть активные наблюдатели, которые вызваны из него, то метод `setValue()` сразу отправит изменения (и будет вызван метод `onChanged` соответственно). Имейте в виду, что данный метод реализуется только в нём. 

>[!warning ] Для фоновых поток есть метод `postValue()`.
##### Принцип работы:

1. Если что-то добавилось в `setValue()`, то он передает сведению в наблюдателю 
2. Наблюдатель обрабатывает это и вызывает `onChanged()` и передает новые данные
3. `onChanged()` получает новые данные и вызывает нашу логику.

##### Таким образом можно сделать вывод:

- `MutableLiveData` — это некий `setter`, мы в него кладем данные
- LiveData.observe() — это некий `getter`, мы подписываем в `Activity` и из него получаем отправленные данные из `MutableLiveData` либо, в нашем случае, из `БД`

Также не стоит возвращать `MutableLiveData`, потому что он вернёт экземпляр себя и также собственные реализованные методы, которые могут нарушить принцип `MVVM`.

Но у нас есть одна проблема, о которой мы несколько раз говорили: `ViewModel` создается как `View-элемент` и пересоздание `Activity` (например, повернули экран), то будет пересоздан и сам. Правило гласит, что `VIewModel` намного живучее, чем `Activity`.

[[Решение проблемы, используя ViewModelProvider]]


